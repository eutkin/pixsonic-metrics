# Pixonic Metrics Store

## Условие задачи

На вход системы поступают метрики (timestamp, ключ, значение), где ключ всегда `char`, `timestamp` в миллисекундах, а значение `int`.

Метрики не являются уникальными. В одну миллисекунду может быть добавлено несколько значений для одного ключа.

Известно, что количество добавляемых метрик настолько велико, что все они **заведомо не влезут в оперативную память 
воображаемого сервера.** 
Также известно, что новые метрики **добавляются с большой скоростью** (больше 10000 метрик в секунду), 
а метод sum вызывается намного реже.

Метрики могут приходить **не по порядку**, например, могут прийти метрики для старого timestamp.

Требуется реализовать **thread-safe** класс с **двумя методами**:


1. Добавляет новое значение метрики
```
void add(long timestamp, char key, int value);
```
2. Возвращает сумму значений всех полученных метрик для указанного ключа в заданном диапазоне времени, 
возвращаемая сумма может быть eventually consistent
```
long sum(long startTimestampInclusive, long endTimestampExclusive, char key);
```

Если реализовать требуемый класс, то следующий код:
```
add(0, 'a', 1);
add(1, 'b', 1);
add(2, 'a', -3);
System.out.println(sum(0, 3, 'a'));
System.out.println(sum(2, 3, 'b'));
System.out.println(sum(0, 1, 'b'));
```

Должен будет вывести в консоль:
```
-2
1
0
```

## Реализация

### Особенности

1. Метрики хранятся в файловой системе. 

2. Каждый файл хранит только метрики с одинаковым ключом и за определенный временный интервал. 
Длина интервала задается через конфигурацию.

3. Запись происходит последовательно, в конец файла. Порядок соответствует порядку, в котором приходили метрики.

### Алгоритм

#### Добавление

1. Вычисляется партиция, в которой будет храниться значение метрики по алгоритму: 
    1. Вычисляется номер партиции по формуле `(timestamp / timeshift) * timeshift`, где
     *timestamp* это время измерения, а *timeshift* это длина интервала, которая может хранить одна партиция
    (одно значение на хранилище).
    2. Вычисляется имя файла `${key}-${номер партиции из пункта выше}`,
    где *key* это имя метрики, смотри `io.github.eutkin.pixonic.metrics.MetricStore.Partition`.
  
2. Из кэша по ключу (Partition) достается I/O канал для записи в файл. Если в кэше его нет, то он создается.

3. Записывается значение метрики (timestamp + value) в бинарном виде.

#### Сумма

1. Вычисляются файлы, в которых хранятся метрики за нужный интервал.
2. Читаем последовательно файл, игнорируя строки, чей timestamp не входит в заданный интервал и суммируем value.
3. Суммируем полученные значения из всех файлов.

В данном случае, I/O каналы не кэшируются, так как подсчет суммы редкая операция и может затрагивать неизвестное количество файлов.
